/*
    924. Minimize Malware Spread

    You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.

    Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, 
    both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.

    Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.

    Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

    Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.

    

    Example 1:

    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    Output: 0
    Example 2:

    Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
    Output: 0
    Example 3:

    Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
    Output: 1
    

    Constraints:

        n == graph.length
        n == graph[i].length
        2 <= n <= 300
        graph[i][j] is 0 or 1.
        graph[i][j] == graph[j][i]
        graph[i][i] == 1
        1 <= initial.length <= n
        0 <= initial[i] <= n - 1
        All the integers in initial are unique. 
*/

#include <vector>
#include <algorithm>
#include <unordered_map>
#include <functional>

using std::unordered_map;
using std::vector;



class Minimize_Malware_SpreadI {

    /*
        924.Minimize-Malware-Spread
        本题依然是根据提供的edg的关系，构建图中的若干连通分量。

        如果一个连通分量里面有两或两个以上的点是初始感染点，那么无论我们隔离哪一个，最终整个连通图还是会全部感染。这种连通图是我们不想要的。

        如果一个连通分量里面只有一个点是初始感染点，那么只要我们隔离了这个点，就能最终拯救整个连通图。显然，我们希望找到最大的这样的连通图，意味着我们可以拯救更多的点，也就是题意里面的minimize M(initial)。

        特别注意，如果所有的连通分量都包含>=2个初始感染点，根据要求我们仍要返回一个点作为最终结果（显然应该是initial里面的最小值）。这意味着尽管我们隔离了这样一个点，但也仅能拯救这一个点而已。
    */
    


public:

    /*
        Approach 2: Union-Find
        Intuition and Algorithm

        As in Approach 1, it is clear that we will need to consider components of the graph. A "Disjoint Set Union" (DSU) data structure is ideal for this.

        We will skip the explanation of how a DSU structure is implemented. Please refer to https://leetcode.com/problems/redundant-connection/solution/ for a tutorial on DSU.

        To our DSU, we can keep a side count of the size of each component. Whenever we union two components together, the size of those components are added.

        With these details neatly handled by our DSU structure, we can continue in a similar manner to Approach 1: for each node in initial with a unique color, we will consider it as a candidate answer. 
        If no node in initial have a unique color, then we will take min(initial) as the answer.

        Note that for brevity, our DSU implementation does not use union-by-rank. This makes the asymptotic time complexity larger.


        Complexity Analysis

        Time Complexity: O(N^2), where NN is the length of graph, as the graph is given in adjacent matrix form.
        Space Complexity: O(N).
    */


    struct MalwareDSU {
   
        vector<int> _parent;
        int N;
        
        MalwareDSU(int n) : N(n) {
            _parent.resize(n);
            for (int i = 0; i < N; i++)
                _parent[i] = i;
        }
        
        int Find(int a) {
            while (a != _parent[a]) {
                _parent[a] = _parent[_parent[a]];
                a = _parent[a];
            }
            return a;
        }
        
        void Union(int a, int b) {
            int pa = Find(a);
            int pb = Find(b);
            _parent[pa] = pb;
        }
    };

    
    // [DSU]
    int doit(vector<vector<int>>&& graph, vector<int>&& initial) {
        
        int N = graph.size();
        MalwareDSU dsu(graph.size());
        
        for (int i = 0; i < graph.size(); i++)
            for (int j = 0; j < i; j++) {
                if (graph[i][j] == 1)
                    dsu.Union(j, i);
            }
        
        vector<int> cnt(graph.size());
        for (auto c : initial) {
            cnt[dsu.Find(c)]++;
        }
        
        unordered_map<int, int> sizes;
        for (int i = 0; i < N; i++)
            sizes[dsu.Find(i)]++;
        
        int ans = *std::min_element(initial.begin(), initial.end()), amount = -1;
        for (auto c : initial) {
            int root = dsu.Find(c);
            if (cnt[root] == 1) {
                int size = sizes[root];
                if (amount < size || (amount == size && c < ans))
                    ans = c, amount = size;
            }
        }
        
        return ans;
    }


    int doit_disjoint(vector<vector<int>>& graph, vector<int>& initial) {
        
        
        int n = graph.size();
        vector<int> father(n);
        
        for (int i = 0; i < n; i++) father[i] = i;
        
        auto find = [&](int a) {
            while (father[a] != a) {
                father[a] = father[father[a]];
                a = father[a];
            }
            return a;
        };
        
        auto merge = [&](int a, int b) {
            int pa = find(a), pb = find(b);
            
            if (pa < pb)
                father[pb] = pa;
            else
                father[pa] = pb;
        };
        
        for (int i = 0; i < n; i++)
            for (int j = 0; j < i; j++) {
                if (graph[j][i] == 1) 
                    merge(j, i);
            }
        
        unordered_map<int, int> sizes;
        for (int i = 0; i < n; i++)
            sizes[find(i)]++;
        
        
        unordered_map<int, int> groups;
        for (auto c: initial)
            groups[find(c)]++;
        
        int ans = *min_element(begin(initial), end(initial)), sz = -1;
        
        for (auto c: initial) {
            
            if (groups[find(c)] == 1) {
                int s = sizes[find(c)];
                if (sz < s || sz == s && ans > c) {
                    ans = c;
                    sz = s;
                }
            }
        }
            
        return ans;
    }
    
    /*
        Approach 1: Depth First Search
        Intuition

        First, let's color (the nodes of) each component of the graph. We can do this using a depth first search.

        Afterwards, notice that if two nodes in initial have the same color (ie., belong to the same component), then removing them from initial won't decrease M(initial). This is because the malware will spread to reach every node in this component no matter what.

        So, among nodes with a unique color in initial, we will remove the node with the largest component size. (If there's a tie, we return the smallest index. Also, if there aren't any nodes with a unique color, we'll just return the smallest index node.)

        Algorithm

        This algorithm has a few parts:

        Coloring each component: For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.

        Size of each color: Count the number of occurrences of each color.

        Find unique colors: Look at the colors of nodes in initial to see which nodes have unique colors.

        Choose answer: For each node with a unique color, find the size of that color. The largest size is selected, with ties broken by lowest node number.

        If there is no node with a unique color, the answer is min(initial).

        Complexity Analysis

        Time Complexity: O(N^2), where NN is the length of graph, as the graph is given in adjacent matrix form.

        Space Complexity: O(N).
    */
    
public:
    
    int doit_dfs(vector<vector<int>>&& graph, vector<int>&& initial) {
        
        int N = graph.size();
        int c = 0;
        unordered_map<int, int> colors;

        std::function<void(int, int)> dfs = [&](int n, int color) {
                colors[n] = color;
                for (int i = 0; i <  graph[n].size(); i++)
                    if (graph[n][i] == 1 && colors.count(i) == 0)
                        dfs(i, color);
        };

        for (int i = 0; i < N; i++)
            if (colors.count(i) == 0) {
                dfs(i, c);
                c++;
            }
        
        unordered_map<int, int> sizes;
        for (auto c : colors)
            sizes[c.second]++;
        
        unordered_map<int, int> colors_amount;
        for (auto c : initial) {
            colors_amount[colors[c]]++;
        }
        
        int ans = -1;
        for (auto c : initial) {
            int color = colors[c];
            if (colors_amount[color] == 1) {
                if (ans == -1)
                    ans = c;
                else if (sizes[color] > sizes[colors[ans]] || (sizes[color] == sizes[colors[ans]] && c < ans))
                    ans = c;
            }
        }
        
        return ans != -1 ? ans : *std::min_element(initial.begin(), initial.end());
    }
    

public:
    vector <int> par;
    vector <vector <int> > inv;
    vector <int> used;
    
    void join(int u, int v) {
        u = par[u], v = par[v];
        if(u == v) return;
        if(inv[u].size() > inv[v].size())
            std::swap(u, v);
        for(auto x: inv[u]) {
            inv[v].push_back(x);
            par[x] = v;
        }
        inv[u].clear();
    }
    
    int doit(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        par.assign(n, 0);
        inv.assign(n, vector <int>());
        used.assign(n, 0);
        
        int result = -1, maxcc = 0;
        for(int i = 0; i < n; i++) {
            par[i] = i;
            inv[i] = {i};
        }
        
        for(int i = 0; i < n; i++)
            for(int j = i + 1; j < n; j++)
                if(graph[i][j])
                    join(i, j);
        
        sort(initial.begin(), initial.end());
        for(auto x: initial)
            used[par[x]]++;
        
        for(auto x: initial)
            if(used[par[x]] == 1 && inv[par[x]].size() > maxcc) {
                result = x;
                maxcc = inv[par[x]].size();
            }
        
        if(result != -1)
            return result;
        
        return *min_element(initial.begin(), initial.end());
    }
};
/*
 
 
 # 928. Minimize Malware Spread II

 # (This problem is the same as Minimize Malware Spread, with the differences bolded.)
 #
 # In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
 #
 # Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware,
 # both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.
 #
 # Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
 #
 # We will remove one node from the initial list, completely removing it and any connections from this node to any other node.
 # Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
 #
 #
 #
 # Example 1:
 #
 # Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 # Output: 0
 # Example 2:
 #
 # Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
 # Output: 1
 # Example 3:
 #
 # Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
 # Output: 1

 # 1 < graph.length = graph[0].length <= 300
 # 0 <= graph[i][j] == graph[j][i] <= 1
 # graph[i][i] = 1
 # 1 <= initial.length < graph.length
 # 0 <= initial[i] < graph.length

 */

#include <vector>
using std::vector;

#include <unordered_map>
using std::unordered_map;

#include <unordered_set>
using std::unordered_set;

class MinMalwareSpread {

    void dfs(int color, int s, vector<vector<int>>& colors, vector<bool>& d, vector<vector<int>>& graph) {
        d[s] = true;
        for (size_t i = 0; i < graph[s].size(); i++) {
            if (graph[s][i] == 1 && ! d[i]) {
                colors[i].push_back(color);
                dfs(color, i, colors, d, graph);
            }
        }
    }

public:
    int doit(vector<vector<int>>&& graph, vector<int>&& initial) {
        
        size_t n = graph.size();
        vector<vector<int>> colors(n, vector<int>{});
        
        vector<bool> base(n, false);
        for (auto c : initial){
            base[c] = true;
        }
        
        for (auto c: initial) {
            vector<bool> d(base);
            dfs(c, c, colors, d, graph);
        }
        
        vector<int> cnt(n, 0);
        for (size_t i = 0; i < colors.size(); i++) {
            if (colors[i].size() == 1)
                cnt[colors[i][0]] += 1;
        }
        
        int index = -1, total = -1;
        for (auto c : initial) {
            if (index == -1 || cnt[c] > total || (total == cnt[c] && c < index)) {
                index = c;
                total = cnt[c];
            }
        }
        
        return index;
    }
    
    
    
    void dfs(int u, vector<int>& s, int& t, vector<int>& et, vector<vector<int>>& edges, vector<int>& p, vector<int>& era, vector<int>& ct, vector<int>& res, vector<bool>& hasM, int& out) {
        s[u] = 1; et[u] = ++t;

        for (int v : edges[u]) {
          if (!s[v]) {
            p[v] = u; era[v] = p[v];
            dfs(v, s, t, et, edges, p, era, ct, res, hasM, out);
          } else if (s[v] != 2)
            if (et[v] < et[era[u]]) era[u] = v;
        }

        s[u] = 2; ct[u] = ++t;
        if (res[p[u]] != -1 && p[u] == era[u] && !hasM[u]) res[p[u]] += ((ct[u] - et[u]) / 2) + 1;
        hasM[p[u]] = hasM[p[u]] || hasM[u];
        if (et[era[u]] < et[era[p[u]]]) era[p[u]] = era[u];

        if (res[out] < res[u] || (res[out] == res[u] && u < out)) out = u;
      }
    
      int minMalwareSpread1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> edges(n, vector<int>());
        for (int i = 0; i < n; ++i)
          for (int j = 0; j < n; ++j)
            if (i != j && graph[i][j]) edges[i].push_back(j);

        vector<bool> hasM(n, false);
        vector<int> res(n, -1); for (int i : initial) hasM[i] = res[i] = 1;
        vector<int> s(n, 0), et(n), p(n), era(n), ct(n);
        int t = 0, out = initial.front();
        for (int u : initial)
          if (!s[u]) dfs(u, s, t, et, edges, p, era, ct, res, hasM, out);
        return out;
      }
    
      int find(int u, vector<int>& p) {
        if (p[u] != u) p[u] = find(p[u], p);
        return p[u];
      }

      void merge(int u, int v, vector<int>& p, vector<int>& size) {
        int r1 = find(u, p), r2 = find(v, p);
        if (r1 != r2)
          if (size[r1] < size[r2]) {
            p[r1] = r2;
            size[r2] += size[r1];
          } else {
            p[r2] = r1;
            size[r1] += size[r2];
          }
      }
    
      int doit1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> p(n, 0); for (int i = 0; i < p.size(); ++i) p[i] = i;
        vector<int> size(n, 1); for (int i : initial) size[i] = 0;
        vector<std::pair<int, int>> edges;
        for (int i = 0; i < n; ++i)
          for (int j = i + 1; j < n; ++j)
            if (graph[i][j]) {
              if (size[i] && size[j]) merge(i, j, p, size);
              else if (!size[i] && size[j]) edges.emplace_back(i, j);
              else if (size[i] && !size[j]) edges.emplace_back(j, i);
            }

        unordered_map<int, unordered_set<int>> rootAndInits;
        for (auto& edge : edges)
          rootAndInits[find(edge.second, p)].insert(edge.first);
        for (auto& rai : rootAndInits)
          if (rai.second.size() == 1) size[*rai.second.begin()] += size[rai.first];

        int out = initial.front();
        for (int i : initial)
          if (size[out] < size[i] || (size[out] == size[i] && i < out)) out = i;
        return out;
      }
};


void test_928_MinimizeMalwareSpreadII() {
    
    auto res1 = MinMalwareSpread().doit(vector<vector<int>>{{1,1,0}, {1,1,0}, {0,0,1}}, vector<int>{0, 1});
    
    auto res2 = MinMalwareSpread().doit(vector<vector<int>>{{1,1,0}, {1,1,1}, {0,1,1}}, vector<int>{0, 1});
    
    auto res3 = MinMalwareSpread().doit(vector<vector<int>>{{1,1,0,0}, {1,1,1,0}, {0,1,1,1}, {0,0,1,1}}, vector<int>{0, 1});
}

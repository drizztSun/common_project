/*
 
 
 # 928. Minimize Malware Spread II

 # (This problem is the same as Minimize Malware Spread, with the differences bolded.)
 #
 # In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
 #
 # Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware,
 # both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.
 #
 # Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
 #
 # We will remove one node from the initial list, completely removing it and any connections from this node to any other node.
 # Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
 #
 #
 #
 # Example 1:
 #
 # Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 # Output: 0
 # Example 2:
 #
 # Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
 # Output: 1
 # Example 3:
 #
 # Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
 # Output: 1

 # 1 < graph.length = graph[0].length <= 300
 # 0 <= graph[i][j] == graph[j][i] <= 1
 # graph[i][i] = 1
 # 1 <= initial.length < graph.length
 # 0 <= initial[i] < graph.length

 */

#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <functional>

using std::queue;
using std::vector;
using std::unordered_map;
using std::unordered_set;

class MinMalwareSpread {

    /*
            928.Minimize-Malware-Spread-II
      本题的切入点是，什么样的node我们可以挽救？答案是邻接的感染源数目为1的node才行。如果某个node邻接的直接感染源（指不需要经过其他感染源就可以到达）的数目为2或以上，说明任何remove的操作都无法征求这个node，总会被其他的感染源所扩散到。

      所以，我们对于某个node，如果它的直接感染源是source且唯一，那么说明我们只要remove source的话，就可以使得这个node免受感染。即这个node是source的“直接保护对象”。如果我们对于每个source，都可以计算出它的直接保护对象的数目。自然答案就是取“直接保护对象”最多的那个感染源。

      怎么高效地求出每个source的“保护对象”的个数呢？这个逻辑有点绕。我们需要先从每个source出发，看看它能直接覆盖到的node（不需要经过其他感染源就可以到达）是哪些，这个用BFS即可。依次类推，重复K次BFS（K是感染源的个数）。最终可以记录下每个node都可以被哪些感染源“直接覆盖”。
      如果某个node的邻近感染源的数目是1时，才给对应的source的“直接保护对象”的计数器加一。于是就解决了这个问题。
    */
    int minMalwareSpread_bfs(vector<vector<int>>& graph, vector<int>& initial) 
    {
        int N = graph.size();
        vector<vector<int>>sources(N); // node -> vector of adjacent infection sources
        unordered_set<int>initials(initial.begin(),initial.end());
        vector<vector<int>>nextNodes(N);

        for (int i=0; i<N; i++)
            for (int j=0; j<N; j++)
                if (i!=j && graph[i][j]==1)
                {
                    nextNodes[i].push_back(j);
                    nextNodes[j].push_back(i);
                }
                    
        for (int start: initial)
        {
            queue<std::pair<int,int>>q;
            q.push({start,start});
            unordered_set<int>visited;
            visited.insert(start);
            
            while (!q.empty())
            {
                int cur = q.front().first;
                int source = q.front().second;
                q.pop();
            
                for (auto next: nextNodes[cur])
                {
                    if (visited.find(next)!=visited.end())
                        continue;
                    if (initials.find(next)!=initials.end())
                        continue;
                    
                    sources[next].push_back(source);
                    
                    q.push({next,source});
                    visited.insert(next);
                }
            }            
        }
        
        unordered_map<int,int>count; // source -> how many nodes can be reached
        for (auto x: sources)
        {
            if (x.size()==1)
            {
                int s = x[0];
                count[s] += 1;
            }
        }
        
        int size = 0;
        int ret = -1;
        for (auto x: count)
        {
            if (x.second > size)
            {
                ret = x.first;
                size = x.second;
            }
            else if (x.second == size && x.first < ret)
                ret = x.first;
        }
        
        if (ret==-1)
        {
            std::sort(initial.begin(),initial.end());
            return initial[0];
        }
        else
            return ret;
        
    }


public:

    int doit_bfs(vector<vector<int>>&& graph, vector<int>&& initial) {
      
      int n = graph.size();
        vector<vector<int>> src(n);
        vector<vector<int>> next(n);
        
        for (int i = 0; i < graph.size(); i++) {
            for (int j = 0; j < graph[i].size(); j++) {
                if (i != j && graph[i][j] == 1) {
                    next[i].push_back(j);
                    next[j].push_back(i);
                }
            }
        }
        
        
        auto bfs = [&](int root) {
          
            vector<int> visited(n, false);
            queue<int> qu;
            qu.push(root);
            visited[root] = true;
            
            while (!qu.empty()) {
                
                int cur = qu.front(); qu.pop();
                
                for (int child: next[cur]) {   
                    if (visited[child]) continue;
                    src[child].push_back(root);
                    qu.push(child);
                    visited[child] = true;
                }
            }
        };
        
        for (auto c: initial) {
            bfs(c);
        }
        
        
        unordered_map<int, int> SZ;
        
        for (int i = 0; i < n; i++) {
            if (src[i].size()==1) {
                SZ[src[i][0]]++;
            }
        }
        
        int minv = 0, index = n+1;
        for (auto it: SZ) {
            if (it.second > minv || (it.second == minv && it.first < index)) {
                minv = it.second;
                index = it.first;
            }
        }
        
        return index;
    }


    int doit_dfs(vector<vector<int>>&& graph, vector<int>&& initial) {
        
        size_t n = graph.size();
        vector<vector<int>> colors(n, vector<int>{});
        
        vector<bool> base(n, false);
        for (auto c : initial){
            base[c] = true;
        }

        std::function<void(int, int, vector<bool>&)> dfs = [&](int color, int s, vector<bool>& d) {
            d[s] = true;
            for (size_t i = 0; i < graph[s].size(); i++) {
                if (graph[s][i] == 1 && !d[i]) {
                    colors[i].push_back(color);
                    dfs(color, i, d);
                }
            }
        };
        
        for (auto c: initial) {
            vector<bool> d(base);
            dfs(c, c, d);
        }
        
        vector<int> cnt(n, 0);
        for (size_t i = 0; i < colors.size(); i++) {
            if (colors[i].size() == 1)
                cnt[colors[i][0]] += 1;
        }
        
        int index = -1, total = -1;
        for (auto c : initial) {
            if (index == -1 || cnt[c] > total || (total == cnt[c] && c < index)) {
                index = c;
                total = cnt[c];
            }
        }
        
        return index;
    }
    
    void dfs(int u, vector<int>& s, int& t, vector<int>& et, vector<vector<int>>& edges, vector<int>& p, vector<int>& era, vector<int>& ct, vector<int>& res, vector<bool>& hasM, int& out) {
        s[u] = 1; et[u] = ++t;

        for (int v : edges[u]) {
          if (!s[v]) {
            p[v] = u; era[v] = p[v];
            dfs(v, s, t, et, edges, p, era, ct, res, hasM, out);
          } else if (s[v] != 2)
            if (et[v] < et[era[u]]) era[u] = v;
        }

        s[u] = 2; ct[u] = ++t;
        if (res[p[u]] != -1 && p[u] == era[u] && !hasM[u]) res[p[u]] += ((ct[u] - et[u]) / 2) + 1;
        hasM[p[u]] = hasM[p[u]] || hasM[u];
        if (et[era[u]] < et[era[p[u]]]) era[p[u]] = era[u];

        if (res[out] < res[u] || (res[out] == res[u] && u < out)) out = u;
      }
    
      int minMalwareSpread1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> edges(n, vector<int>());
        for (int i = 0; i < n; ++i)
          for (int j = 0; j < n; ++j)
            if (i != j && graph[i][j]) edges[i].push_back(j);

        vector<bool> hasM(n, false);
        vector<int> res(n, -1); for (int i : initial) hasM[i] = res[i] = 1;
        vector<int> s(n, 0), et(n), p(n), era(n), ct(n);
        int t = 0, out = initial.front();
        for (int u : initial)
          if (!s[u]) dfs(u, s, t, et, edges, p, era, ct, res, hasM, out);
        return out;
      }
    
      int find(int u, vector<int>& p) {
        if (p[u] != u) p[u] = find(p[u], p);
        return p[u];
      }

      void merge(int u, int v, vector<int>& p, vector<int>& size) {
        int r1 = find(u, p), r2 = find(v, p);
        if (r1 != r2)
          if (size[r1] < size[r2]) {
            p[r1] = r2;
            size[r2] += size[r1];
          } else {
            p[r2] = r1;
            size[r1] += size[r2];
          }
      }
    
      int doit1(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> p(n, 0); for (int i = 0; i < p.size(); ++i) p[i] = i;
        vector<int> size(n, 1); for (int i : initial) size[i] = 0;
        vector<std::pair<int, int>> edges;
        for (int i = 0; i < n; ++i)
          for (int j = i + 1; j < n; ++j)
            if (graph[i][j]) {
              if (size[i] && size[j]) merge(i, j, p, size);
              else if (!size[i] && size[j]) edges.emplace_back(i, j);
              else if (size[i] && !size[j]) edges.emplace_back(j, i);
            }

        unordered_map<int, unordered_set<int>> rootAndInits;
        for (auto& edge : edges)
          rootAndInits[find(edge.second, p)].insert(edge.first);
        for (auto& rai : rootAndInits)
          if (rai.second.size() == 1) size[*rai.second.begin()] += size[rai.first];

        int out = initial.front();
        for (int i : initial)
          if (size[out] < size[i] || (size[out] == size[i] && i < out)) out = i;
        return out;
      }
};
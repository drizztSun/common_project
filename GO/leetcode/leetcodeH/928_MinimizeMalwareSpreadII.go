package leetcodeH

func dfs_spread(color, i int, colors map[int][]int, seen map[int]bool, graph [][]int) {
	seen[i] = true
	for j := range graph[i] {
		if graph[i][j] == 1 {
			if _, ok := seen[j]; !ok {
				colors[j] = append(colors[j], color)
				dfs_spread(color, j, colors, seen, graph)
			}
		}
	}
}
func minMalwareSpread(graph [][]int, initial []int) int {

	N := len(graph)

	colors := make(map[int][]int)

	for _, c := range initial {
		seen := make(map[int]bool)
		for _, s := range initial {
			seen[s] = true
		}

		dfs_spread(c, c, colors, seen, graph)
	}

	cnt := make([]int, N)
	for _, c := range colors {
		if len(c) == 1 {
			cnt[c[0]] += 1
		}
	}

	index, total := -1, -1

	for _, c := range initial {
		if index == -1 || total < cnt[c] || (total == cnt[c] && index > c) {
			index, total = c, cnt[c]
		}
	}

	return index
}

func Test_928_MinimizeMalwareSpreadII() {

	minMalwareSpread([][]int{[]int{1, 1, 0}, []int{1, 1, 1}, []int{0, 1, 1}}, []int{0, 1})

	minMalwareSpread([][]int{[]int{1, 1, 0, 0}, []int{1, 1, 1, 0}, []int{0, 1, 1, 1}, []int{0, 0, 1, 1}}, []int{0, 1})

	minMalwareSpread([][]int{[]int{1, 1, 1, 0}, []int{1, 1, 0, 0}, []int{1, 0, 1, 0}, []int{0, 0, 0, 1}}, []int{3, 2})
}

use std::pin::Pin;
use std::marker::PhantomPinned;
use std::mem;


/*

Summary
1. If T: Unpin (which is the default), then Pin<'a, T> is entirely equivalent to &'a mut T.
    in other words: Unpin means it's OK for this type to be moved even when pinned, so Pin will have no effect on such a type.

2. Getting a &mut T to a pinned T requires unsafe if T: !Unpin.

3. Most standard library types implement Unpin. The same goes for most "normal" types you encounter in Rust. A Future generated by async/await is an exception to this rule.

4. You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.

5. You can either pin data to the stack or to the heap.

6. Pinning a !Unpin object to the stack requires unsafe

7. Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.

8. For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called.
   This is an important part of the pin contract.


*/



/*

Pinning in Practice
Let's see how pinning and the Pin type can help us solve this problem.

The Pin type wraps pointer types, guaranteeing that the values behind the pointer won't be moved. For example, Pin<&mut T>, Pin<&T>, Pin<Box<T>> all guarantee that T won't be moved if T: !Unpin.

Most types don't have a problem being moved. These types implement a trait called Unpin. Pointers to Unpin types can be freely placed into or taken out of Pin.
For example, u8 is Unpin, so Pin<&mut u8> behaves just like a normal &mut u8.

However, types that can't be moved after they're pinned has a marker called !Unpin. Futures created by async/await is an example of this.

*/

#[derive(Debug)]
struct Test{
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {

    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type '!Unpin'
        }
    }

    fn init<'a>(self: Pin<&'a mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a str {
        unsafe{ &*(self.b)}
    }
}

/*

Pinning an object to the stack will always be unsafe if our type implements !Unpin.
You can use a crate like pin_utils to avoid writing our own unsafe code when pinning to the stack.

*/
fn test_pin_on_stack() {

    {
        // test1 is safe to move before we initialize it
        let mut test1 = Test::new("test1");
        // Notice how we shadow `test1` to prevent it from being accessed again
        let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
        Test::init(test1.as_mut());

        let mut test2 = Test::new("test2");
        let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
        Test::init(test2.as_mut());

        println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));

        // `std::marker::PhantomPinned` cannot be unpinned, within `test_pin::Test`, the trait `std::marker::Unpin` is not implemented for `std::marker::PhantomPinned`
        // std::mem::swap(test1.get_mut(), test2.get_mut());

        println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
    }


    {
        /*

        The type system prevents us from moving the data.

        It's important to note that stack pinning will always rely on guarantees you give when writing unsafe.
        While we know that the pointee of &'a mut T is pinned for the lifetime of 'a we can't know if the data &'a mut T points to isn't moved after 'a ends. If it does it will violate the Pin contract.

        A mistake that is easy to make is forgetting to shadow the original variable since you could drop the Pin and move the data after &'a mut T like shown below (which violates the Pin contract):

        */

        let mut test1 = Test::new("test1");
        let mut test1_pin = unsafe { Pin::new_unchecked(&mut test1) };
        Test::init(test1_pin.as_mut());
        drop(test1_pin);
        println!(r#"test1.b points to "test1": {:?}..."#, test1.b);
        let mut test2 = Test::new("test2");
        mem::swap(&mut test1, &mut test2);
        println!("... and now it points nowhere: {:?}", test1.b);
    }
}

/*

Pinning to the Heap
Pinning an !Unpin type to the heap gives our data a stable address so we know that the data we point to can't move after it's pinned.
In contrast to stack pinning, we know that the data will be pinned for the lifetime of the object.

*/

#[derive(Debug)]
struct TestH {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl TestH {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = TestH {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a String {
        unsafe { &*(self.b) }
    }
}

fn test_pin_on_heap() {
    let mut test1 = TestH::new("test1");
    let mut test2 = TestH::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}


pub fn test_pin() {

    test_pin_on_heap();

    test_pin_on_stack();
}